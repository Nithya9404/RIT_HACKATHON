# -*- coding: utf-8 -*-
"""MEDCARE AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GiyYgnYTAbV9nBucrD1IwDMZOw4VsM5J
"""

!pip install streamlit

!pip install pyngrok

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import streamlit as st
# import pandas as pd
# 
# # Load your datasets
# updated_drug_df = pd.read_csv("updated_drg.csv")
# preprocessed_description_df = pd.read_csv("preprocessed_PRESCRIPTIONS.csv")
# 
# # Create a Streamlit app
# st.title("Disease Progression Dashboard")
# 
# # Display your datasets
# st.subheader("Updated Drug Dataset")
# st.dataframe(updated_drug_df)
# 
# st.subheader("Preprocessed Description Dataset")
# st.dataframe(preprocessed_description_df)
# 
# import streamlit as st
# import pandas as pd
# from sklearn.model_selection import train_test_split
# from sklearn.linear_model import LogisticRegression
# from sklearn.metrics import accuracy_score, classification_report
# from sklearn.cluster import KMeans
# import matplotlib.pyplot as plt
# 
# # Load the data
# data = pd.read_csv("/content/updated_drg.csv")
# 
# # Create a Streamlit app
# st.title("Healthcare Data Analysis")
# 
# # Display the data
# st.header("Dataset")
# st.write(data)
# 
# # Split the data into training and testing sets
# features = ["drg_code", "drg_severity", "drg_mortality"]
# target = "Risk"
# X_train, X_test, y_train, y_test = train_test_split(data[features], data[target], test_size=0.2, random_state=42)
# 
# # Train a logistic regression model
# st.header("Logistic Regression Model")
# model = LogisticRegression()
# model.fit(X_train, y_train)
# y_pred = model.predict(X_test)
# 
# # Evaluate the model
# accuracy = accuracy_score(y_test, y_pred)
# classification_report_text = classification_report(y_test, y_pred)
# 
# st.subheader("Model Evaluation")
# st.write(f"Accuracy: {accuracy}")
# st.write("Classification Report:")
# st.code(classification_report_text)
# 
# # Select relevant features for clustering and segmentation
# cluster_features = ["drg_severity", "drg_mortality"]
# 
# # Choose the number of clusters (K) based on your data and objectives
# n_clusters = st.slider("Select the number of clusters", min_value=2, max_value=10, value=4)
# 
# # Apply K-Means clustering
# kmeans = KMeans(n_clusters=n_clusters)
# data['cluster'] = kmeans.fit_predict(data[cluster_features])
# 
# # Visualize the clusters
# st.header("K-Means Clustering for Severity of Illness")
# fig, ax = plt.subplots()
# scatter = ax.scatter(data["drg_severity"], data["drg_mortality"], c=data["cluster"], cmap='viridis')
# ax.set_xlabel("DRG Severity")
# ax.set_ylabel("DRG Mortality")
# ax.set_title("K-Means Clustering for Severity of Illness")
# st.pyplot(fig)
# 
# # Interpret the clusters
# cluster_centers = kmeans.cluster_centers_
# 
# st.subheader("Cluster Centers")
# st.write(cluster_centers)
# 
# # Segment patients based on the clusters
# segmented_patients = [data[data['cluster'] == i] for i in range(n_clusters)]
# 
# st.subheader("Segments Based on Clusters")
# fig, ax = plt.subplots()
# for i, segment in enumerate(segmented_patients):
#     ax.scatter(segment["drg_severity"], segment["drg_mortality"], label=f"Segment {i}")
# ax.set_xlabel("DRG Severity")
# ax.set_ylabel("DRG Mortality")
# ax.set_title("Segments Based on Clusters")
# ax.legend()
# st.pyplot(fig)
# 
# st.title("Data Visualizations")
# 
# import streamlit as st
# import pandas as pd
# import matplotlib.pyplot as plt
# import seaborn as sns
# from io import BytesIO
# 
# # Display the data
# st.header("Dataset")
# st.write(data)
# 
# # Histogram of drg_severity
# st.header("Histogram of Severity of Illness")
# fig, ax = plt.subplots()
# ax.hist(data['drg_severity'], bins=20, color='blue', alpha=0.5)
# ax.set_xlabel('Severity of Illness (DRG Severity)')
# ax.set_ylabel('Frequency')
# st.pyplot(fig)
# 
# # Density plot of drg_mortality
# st.header("Density Plot of Mortality")
# fig, ax = plt.subplots()
# data['drg_mortality'].plot.kde(color='red', ax=ax)
# ax.set_xlabel('Mortality (DRG Mortality)')
# ax.set_ylabel('Density')
# st.pyplot(fig)
# 
# # Scatter plot of drg_severity vs drg_mortality
# st.header("Scatter Plot of Severity vs. Mortality")
# fig, ax = plt.subplots()
# scatter = ax.scatter(data['drg_severity'], data['drg_mortality'], c='green', alpha=0.5)
# ax.set_xlabel('Severity of Illness (DRG Severity)')
# ax.set_ylabel('Mortality (DRG Mortality)')
# st.pyplot(fig)
# 
# 
# # Box plot of drg_severity and drg_mortality
# st.header("Box Plot of Severity and Mortality")
# fig, ax = plt.subplots()
# data[['drg_severity', 'drg_mortality']].plot(kind='box', vert=False, patch_artist=True, ax=ax)
# ax.set_xlabel('Value')
# image = BytesIO()
# plt.savefig(image, format='png')
# st.image(image)
# 
# # Super title for the Pair Plot
# st.header("Pair Plot of Severity, Mortality, and Risk")
# sns_plot = sns.pairplot(data[['drg_severity', 'drg_mortality', 'Risk']], hue='Risk', diag_kind='kde')
# image = BytesIO()
# sns_plot.savefig(image, format='png')
# st.image(image)
# st.write('Pair Plot of Severity, Mortality, and Risk')  # Super title with text
# 
# st.title("Healthcare Data Analysis")
# import pandas as pd
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.linear_model import LinearRegression
# 
# 
# # Display the data
# st.header("Dataset")
# st.write(data)
# 
# # ... (Previous code for logistic regression and K-Means clustering)
# 
# # Add a section for prediction
# st.header("Patient Severity and Mortality Prediction")
# 
# # Input for patient description
# patient_description = st.text_area("Enter the patient description:")
# 
# # Button to trigger prediction
# if st.button("Predict"):
#     X = data['description']
#     y_severity = data['drg_severity']
#     y_mortality = data['drg_mortality']
# 
#     # Create a TF-IDF vectorizer to convert text descriptions to numerical features
#     tfidf_vectorizer = TfidfVectorizer(max_features=5000)  # Adjust max_features as needed
#     X_tfidf = tfidf_vectorizer.fit_transform(X)
# 
#     # Train a Linear Regression model for severity
#     model_severity = LinearRegression()
#     model_severity.fit(X_tfidf, y_severity)
# 
#     # Train a Linear Regression model for mortality
#     model_mortality = LinearRegression()
#     model_mortality.fit(X_tfidf, y_mortality)
# 
#     # Example patient description
#     print("patient_description",input())
# 
#     # Transform the patient description to a TF-IDF vector
#     patient_description_tfidf = tfidf_vectorizer.transform([patient_description])
# 
#     # Make predictions
#     prediction_severity = model_severity.predict(patient_description_tfidf)[0]
#     prediction_mortality = model_mortality.predict(patient_description_tfidf)[0]
# 
#     # Display the predictions
#     st.subheader("Predictions:")
#     st.write(f"Predicted Severity: {prediction_severity:.2f}")
#     st.write(f"Predicted Mortality: {prediction_mortality:.2f}")
# 
# 
# 
# 
# 
# 
#

!streamlit run app.py &>/dev/null&

!ngrok authtoken 2XWTBphJxJsxC5wmlG3ImA52xUo_4Zv9S98fNuBXZNwqwDhhm

!wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip

!unzip ngrok-stable-linux-amd64.zip

get_ipython().system_raw('./ngrok http 8501 &')
!curl -s http://localhost:4040/api/tunnels | python3 -c "import sys, json; print(json.load(sys.stdin)['tunnels'][0]['public_url'])"

!streamlit run /content/app.py